# -*- coding: utf-8 -*-
"""DSP for Assignment2 - API step 2 api.py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RiQG6HcGsL5x-bsZNVo8sG4jVyehNxCG
"""

from __future__ import annotations

from google.colab import drive
drive.mount('/content/drive')

"""
Low-level HTTP client for Frankfurter API.
This module only knows how to call endpoints and return parsed JSON.
Business logic (extracting a single rate, formatting texts, etc.)
should live in frankfurter.py / currency.py.
"""

from datetime import date, datetime
from typing import Any, Dict, Iterable, Optional, Union

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

BASE_URL = "https://api.frankfurter.app"

class ApiError(RuntimeError):
    """Wrap HTTP/network/parse errors for clearer upstream handling."""
    pass


def _build_session() -> requests.Session:
    """Create a requests session with retries and sensible timeouts."""
    session = requests.Session()
    retry = Retry(
        total=3,
        read=3,
        connect=3,
        backoff_factor=0.3,
        status_forcelist=(429, 500, 502, 503, 504),
        allowed_methods=frozenset(["GET"]),
        raise_on_status=False,
    )
    adapter = HTTPAdapter(max_retries=retry)
    session.mount("https://", adapter)
    session.mount("http://", adapter)
    return session

# A single shared session (safe for Streamlit's single-threaded execution model)
_SESSION = _build_session()


def _iso_date(d: Union[str, date, datetime]) -> str:
    """Return YYYY-MM-DD for date-like inputs; pass through ISO strings."""
    if isinstance(d, str):
        # Basic sanity check; let server validate details
        if len(d) == 10 and d[4] == "-" and d[7] == "-":
            return d
        # Try parsing flexible strings
        try:
            return datetime.fromisoformat(d).date().isoformat()
        except Exception as exc:
            raise ApiError(f"Invalid date string: {d}") from exc
    if isinstance(d, datetime):
        return d.date().isoformat()
    if isinstance(d, date):
        return d.isoformat()
    raise ApiError(f"Unsupported date type: {type(d)}")

def _comma_list(symbols: Union[str, Iterable[str]]) -> str:
    """Normalize symbols argument to a comma-separated string without spaces."""
    if isinstance(symbols, str):
        return symbols.replace(" ", "")
    try:
        return ",".join(str(s).strip() for s in symbols)
    except Exception as exc:
        raise ApiError("symbols must be a string or an iterable of strings") from exc


def _get(path: str, params: Optional[Dict[str, Any]] = None, timeout: float = 8.0) -> Dict[str, Any]:
    """Perform a GET request and return parsed JSON or raise ApiError."""
    url = f"{BASE_URL}{path}"
    try:
        resp = _SESSION.get(url, params=params or {}, timeout=timeout)
        # If retries exhausted or non-2xx, raise for status to surface reason
        resp.raise_for_status()
        return resp.json()
    except requests.exceptions.HTTPError as e:
        # Attach server message if available
        detail = ""
        try:
            detail = f" â€” {resp.text[:200]}"
        except Exception:
            pass
        raise ApiError(f"HTTP {resp.status_code} for {url}{detail}") from e
    except requests.exceptions.RequestException as e:
        raise ApiError(f"Network error calling {url}: {e}") from e
    except ValueError as e:
        raise ApiError(f"Failed to parse JSON from {url}") from e

# Public API functions (used by frankfurter.py)
# -----------------------------

def currencies() -> Dict[str, str]:
    """
    GET /currencies
    Returns a mapping { 'AUD': 'Australian Dollar', ... }
    """
    return _get("/currencies")


def latest(base: str, symbols: Union[str, Iterable[str]], amount: Optional[float] = None) -> Dict[str, Any]:
    """
    GET /latest?from=<base>&to=<csv>&amount=<amount?>
    Returns JSON like:
    {
      "amount": 1.0,
      "base": "AUD",
      "date": "2025-09-05",
      "rates": {"USD": 0.65}
    }
    """
    params: Dict[str, Any] = {
        "from": base,
        "to": _comma_list(symbols),
    }
    if amount is not None:
        params["amount"] = amount
    return _get("/latest", params=params)


def historical(on_date: Union[str, date, datetime], base: str, symbols: Union[str, Iterable[str]], amount: Optional[float] = None) -> Dict[str, Any]:
    """
    GET /YYYY-MM-DD?from=<base>&to=<csv>&amount=<amount?>
    Returns JSON like:
    {
      "amount": 1.0,
      "base": "AUD",
      "date": "2023-07-10",
      "rates": {"USD": 0.67}
    }
    """
    day = _iso_date(on_date)
    params: Dict[str, Any] = {
        "from": base,
        "to": _comma_list(symbols),
    }
    if amount is not None:
        params["amount"] = amount
    return _get(f"/{day}", params=params)