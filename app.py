# -*- coding: utf-8 -*-
"""DSP for Assignment2 - API step 1 app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QJHeb8Hcv0cxxzPS28_Xtgy97E1onw1q
"""

from __future__ import annotations

from google.colab import drive
drive.mount('/content/drive')

pip install streamlit

# app.py
import streamlit as st
from datetime import date
from typing import Dict

# è¿™äº›æ¨¡å—ä¸å‡½æ•°ç”±ä½ åœ¨å…¶ä»–æ–‡ä»¶ä¸­å®ç°ï¼š
# frankfurter.py: æ•°æ®è·å–ï¼ˆå¯¹ API çš„å…·ä½“å°è£…ï¼‰
# currency.py:    ç»“æœæ–‡æœ¬æ ¼å¼åŒ–
from frankfurter import get_currencies, get_latest_rate, get_historical_rate
from currency import format_result

# ------------ é¡µé¢åŸºç¡€è®¾ç½® ------------
st.set_page_config(
    page_title="Currency Converter",
    page_icon="ğŸ’±",
    layout="centered"
)

st.title("ğŸ’± Currency Converter (Frankfurter API)")
st.caption("Get latest and historical FX rates. Built with Streamlit + Frankfurter.")

# ------------ ç¼“å­˜ï¼šåŠ è½½è´§å¸ä»£ç  ------------
@st.cache_data(ttl=6 * 60 * 60)  # 6 å°æ—¶æ›´æ–°ä¸€æ¬¡
def load_currencies() -> Dict[str, str]:
    """
    è¿”å›å­—å…¸ï¼š{code: name}
    """
    data = get_currencies()  # ä¾‹å¦‚ {"AUD": "Australian Dollar", ...}
    # ç¡®ä¿æœ‰åºä¸æ˜“é€‰
    return dict(sorted(data.items(), key=lambda kv: kv[0]))

curr_map = load_currencies()
codes = list(curr_map.keys())

if not codes:
    st.error("Failed to load currencies. Please check your frankfurter implementation.")
    st.stop()

# ------------ ç”¨æˆ·è¾“å…¥åŒºåŸŸ ------------
st.subheader("1) Choose currencies and amount")
col1, col2 = st.columns(2)

with col1:
    from_code = st.selectbox(
        "From currency",
        options=codes,
        index=codes.index("AUD") if "AUD" in codes else 0,
        format_func=lambda c: f"{c} â€” {curr_map[c]}"
    )

with col2:
    to_code = st.selectbox(
        "To currency",
        options=codes,
        index=codes.index("USD") if "USD" in codes else 0,
        format_func=lambda c: f"{c} â€” {curr_map[c]}"
    )

amount = st.number_input(
    "Amount to convert",
    min_value=0.0,
    value=100.0,
    step=1.0,
    help="Enter a non-negative amount."
)

# å‹å¥½æ ¡éªŒ
if amount < 0:
    st.warning("Amount should be non-negative.")

# ------------ æœ€æ–°æ±‡ç‡è½¬æ¢ ------------
st.subheader("2) Latest conversion")
latest_btn = st.button("Get latest rate ğŸ”„")

if latest_btn:
    try:
        if from_code == to_code:
            # åŒå¸ç§ï¼šæ±‡ç‡=1ï¼Œé¿å…æ— æ„ä¹‰è¯·æ±‚
            rate = 1.0
        else:
            rate = float(get_latest_rate(from_code, to_code))

        today_str = date.today().isoformat()
        msg = format_result(today_str, from_code, to_code, rate, amount)
        st.success(msg)
    except Exception as e:
        st.error(f"Failed to fetch latest rate: {e}")

# ------------ å†å²æ±‡ç‡è½¬æ¢ ------------
st.subheader("3) Historical conversion")
hist_date = st.date_input(
    "Pick a past date",
    value=date.today(),
    max_value=date.today(),
    help="Choose a date to get that day's conversion."
)
hist_btn = st.button("Get rate for this date ğŸ“…")

if hist_btn:
    try:
        if from_code == to_code:
            rate = 1.0
        else:
            rate = float(get_historical_rate(hist_date, from_code, to_code))

        msg = format_result(hist_date.isoformat(), from_code, to_code, rate, amount)
        st.success(msg)
    except Exception as e:
        st.error(f"Failed to fetch historical rate: {e}")

# ------------ ä¾§è¾¹æ å°è´´å£« ------------
with st.sidebar:
    st.markdown("### Tips")
    st.markdown(
        "- Latest: uses today's rate.\n"
        "- Historical: uses the rate for the selected date.\n"
        "- Inverse rate is also shown in the result message."
    )
    st.markdown("---")
    st.markdown("**Data Source:** Frankfurter.app")

# frankfurter.py
import requests
from datetime import date

BASE_URL = "https://api.frankfurter.app"

def get_currencies():
    """Fetches available currencies from the Frankfurter API."""
    try:
        response = requests.get(f"{BASE_URL}/currencies")
        response.raise_for_status()  # Raise an exception for bad status codes
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching currencies: {e}")
        return {}

def get_latest_rate(from_currency, to_currency):
    """Fetches the latest exchange rate between two currencies."""
    try:
        response = requests.get(f"{BASE_URL}/latest", params={"from": from_currency, "to": to_currency})
        response.raise_for_status()
        data = response.json()
        # The API returns rates for all 'to' currencies if specified, or just the base if not.
        # We expect a single rate here.
        if 'rates' in data and to_currency in data['rates']:
             return data['rates'][to_currency]
        else:
             raise ValueError(f"Rate for {to_currency} not found in response.")
    except requests.exceptions.RequestException as e:
        print(f"Error fetching latest rate: {e}")
        return None
    except ValueError as e:
        print(f"Error parsing latest rate response: {e}")
        return None


def get_historical_rate(date_obj: date, from_currency, to_currency):
    """Fetches the historical exchange rate for a given date."""
    date_str = date_obj.isoformat()
    try:
        response = requests.get(f"{BASE_URL}/{date_str}", params={"from": from_currency, "to": to_currency})
        response.raise_for_status()
        data = response.json()
        if 'rates' in data and to_currency in data['rates']:
             return data['rates'][to_currency]
        else:
             raise ValueError(f"Rate for {to_currency} not found in response for date {date_str}.")
    except requests.exceptions.RequestException as e:
        print(f"Error fetching historical rate: {e}")
        return None
    except ValueError as e:
        print(f"Error parsing historical rate response: {e}")
        return None

# currency.py
from datetime import date

def format_result(date_str: str, from_code: str, to_code: str, rate: float, amount: float) -> str:
    """Formats the conversion result message."""
    converted_amount = amount * rate
    inverse_rate = 1 / rate if rate != 0 else float('inf') # Handle division by zero

    msg = f"On {date_str}, {amount:.2f} {from_code} is equal to {converted_amount:.2f} {to_code}.\n\n"
    msg += f"Exchange Rate: 1 {from_code} = {rate:.4f} {to_code}\n"
    msg += f"Inverse Rate: 1 {to_code} = {inverse_rate:.4f} {from_code}"

    return msg

# Commented out IPython magic to ensure Python compatibility.
# %%writefile frankfurter.py
# import requests
# from datetime import date
# 
# BASE_URL = "https://api.frankfurter.app"
# 
# def get_currencies():
#     """Fetches available currencies from the Frankfurter API."""
#     try:
#         response = requests.get(f"{BASE_URL}/currencies")
#         response.raise_for_status()  # Raise an exception for bad status codes
#         return response.json()
#     except requests.exceptions.RequestException as e:
#         print(f"Error fetching currencies: {e}")
#         return {}
# 
# def get_latest_rate(from_currency, to_currency):
#     """Fetches the latest exchange rate between two currencies."""
#     try:
#         response = requests.get(f"{BASE_URL}/latest", params={"from": from_currency, "to": to_currency})
#         response.raise_for_status()
#         data = response.json()
#         # The API returns rates for all 'to' currencies if specified, or just the base if not.
#         # We expect a single rate here.
#         if 'rates' in data and to_currency in data['rates']:
#              return data['rates'][to_currency]
#         else:
#              raise ValueError(f"Rate for {to_currency} not found in response.")
#     except requests.exceptions.RequestException as e:
#         print(f"Error fetching latest rate: {e}")
#         return None
#     except ValueError as e:
#         print(f"Error parsing latest rate response: {e}")
#         return None
# 
# 
# def get_historical_rate(date_obj: date, from_currency, to_currency):
#     """Fetches the historical exchange rate for a given date."""
#     date_str = date_obj.isoformat()
#     try:
#         response = requests.get(f"{BASE_URL}/{date_str}", params={"from": from_currency, "to": to_currency})
#         response.raise_for_status()
#         data = response.json()
#         if 'rates' in data and to_currency in data['rates']:
#              return data['rates'][to_currency]
#         else:
#              raise ValueError(f"Rate for {to_currency} not found in response for date {date_str}.")
#     except requests.exceptions.RequestException as e:
#         print(f"Error fetching historical rate: {e}")
#         return None
#     except ValueError as e:
#         print(f"Error parsing historical rate response: {e}")
#         return None

# Commented out IPython magic to ensure Python compatibility.
# %%writefile currency.py
# from datetime import date
# 
# def format_result(date_str: str, from_code: str, to_code: str, rate: float, amount: float) -> str:
#     """Formats the conversion result message."""
#     converted_amount = amount * rate
#     inverse_rate = 1 / rate if rate != 0 else float('inf') # Handle division by zero
# 
#     msg = f"On {date_str}, {amount:.2f} {from_code} is equal to {converted_amount:.2f} {to_code}.\n\n"
#     msg += f"Exchange Rate: 1 {from_code} = {rate:.4f} {to_code}\n"
#     msg += f"Inverse Rate: 1 {to_code} = {inverse_rate:.4f} {from_code}"
# 
#     return msg